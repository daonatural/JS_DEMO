// 3 请问变量a会被GC回收么，为什么呢
function test() {
  var a = 1;
  return function() {
    eval("");
  };
}

var fn = test();
fn();


// 答案： 不会
// 考察的是 闭包，垃圾回收和eval(不会对js的词法环境解绑) - 为什么
// 1 什么是GC - Garbage Collection - 垃圾回收 - js中也存在垃圾回收，回收有两种方式：标记清除（mark and sweep）、引用计数(reference counting)。
// - 标记清除 - 大部分浏览器使用此方法，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，离开环境后的变量就是需要被删除的变量
// - 计数引用 - 老IE使用此方法，机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减1。当该值引用次数为0时就会被回收。

// 2 - 闭包，如果父级作用域的变量被闭包中的代码块引用的，就算离开当前执行环境，此变量也不会被回收，但如果没有引用的变量任然会被回收

// 3 - eval能够将输入的字符串作为js代码执行，它如果存在，就算闭包中没有直接引用外部变量，变量也不会被回收，因为“不敢回收”，js解析器不确定eval中是否有使用外部变量的语句



