# 数据结构

> 几个概念：

- 数据：能输入到计算机的“东西”都算是数据，包括 文字，视频，音频...
- 数据对象：它是一个比较大的单位，比如一份图片，一份 mp3...
- 数据元素：表示一个东西的最小单位，比如一个人，注意这个单位是要有意义的。比如：单独拿出年龄出来时没有意义的，这些属性组合成人后才有意义
- 数据项：最小属性单位，不可再分割的东西。

多个数据项 --组合--> 数据元素 --组合--> 数据对象 --组合--> 数据

数据结构和算法密不可分，数据存储后要用算法操作数据，不然就毫无意义

> 数据结构的分类方法；

![img](/static/data-struct.png)

- 按照逻辑分类（设计层面）

  - 集合（无逻辑关系）
  - 线性结构（线性表）- 按照顺序结构实现的叫【顺序表】，按照链式结构实现的叫【链表】（元素之间 1：1）
    - 一维数组
    - 队列
    - 栈
  - 非线性结构
    - 树（元素之间 1：N）
    - 图（元素之间 N：N）
    - 多维数组

- 按照存储结构（实现层面）
  - 顺序存储结构
  - 链式存储结构
  - 索引存储结构
  - 散列存储结构

内存可以理解为只有一行格子的很长的稿纸，每个格子只能写一个字节：

- 顺序存储

  - 在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素,称作线性表的顺序存储结构
  - example: 数组，数组遍历是当前数组的地址，下标则是根据当前地址配合下标计算偏移量获数组中某项具体的值
  - 特点：随机存取表中元素，插入和删除操作需要移动元素

- 链式存储结构：

  - 不是顺序的，想存在哪就存在哪，但有个问题，没有顺序那样连续性的规律如何找到每个字节呢？通过一个链去寻找，链式结构每个单独的元素中分为两部分，一部分保存数据，另一部分保存指针。比如每个指针指向后面元素的地址。
  - 在计算机中用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的,也可以是不连续的)
  - 它不要求逻辑上相邻的元素在物理位置上也相邻.因此它没有顺序存储结构所具有的弱点,但也同时失去了顺序表可随机存取的优点
  - 特点
    - 比顺序存储结构的存储密度小 (每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多)
    - 逻辑上相邻的节点物理上不必相邻
    - 插入、删除灵活 (不必移动节点，只要改变节点中的指针)
    - 查找结点时链式存储要比顺序存储慢
    - 每个结点是由数据域和指针域组成

- 索引存储结构：

  - 是一种复合型（顺序+链式）存储结构
  - 除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成
  - 特点：索引存储结构是用结点的索引号来确定结点存储地址，其优点是检索速度快，缺点是增加了附加的索引表,会占用较多的存储空间

- 散列结构：
  - 散列存储，又称 hash 存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术
  - 散列法存储的基本思想是：由节点的关键码值决定节点的存储地址，散列技术除了可以用于查找外，还可以用于存储
  - 特点：散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的，而不像在数组中的遍历过程，采用存储数组中内容的部分元素作为映射函数的输入，映射函数的输出就是存储数据的位置，这样的访问速度就省去了遍历数组的实现，因此时间复杂度可以认为为 O(1)，而数组遍历的时间复杂度为 O(n)
  - 散列结构可以是多维数组（C 语言）

---

- 集合（数据结构中集合关系就类似于数学中的集合）- 比如：js 中的 Set

  - 集合中的数据成员是无序的
  - 每个数据成员在集合中不能重复，仅仅出现一次

- 线性表

  - 线性结构中的数据元素是 1 对 1 的关系，也是数据元素一个接一个排列。
  - 用来存放特定的某一类型的元素
  - 从线性表中拿取一个元素，此元素前面一个元素称为此元素的前驱元素，后面一个元素称为此元素的后继元素
  - 物理结构为顺序表或者链表

- 线性表的衍生结构：
  - 栈 （是一种被限制操作的线性表）
    - 只能在一端进行操作（栈顶），在空栈的情况下，栈顶和栈底是一个位置
    - 入栈时，先存的在栈底，后存的在栈顶。出栈时，后被放进去的先可以被取出 （类似桶装薯片）【lifo last in first out - 后进先出, 先进后出】
    - 计算机中使用栈的情况非常多
      - 函数的多层次调用，每个函数的局部变量就是存在栈中
      - 四则运算符的优先级
      - 浏览器的后退和 IDE 的 Undo
  - 队列 （是一种被限制操作的线性表）
    - 两头可以操作，中间不能操作，一端只能向里面写（从队尾入队），一端只能删,读出来（从对首出队）【类似排队买票】
    - 先入队的也先出队【fifo - first in first out, 先进先出】
    - 使用情况：
      - 消息队列，视频弹幕
      - 维护打印机的任务
  - 串 （字符串，特殊的数组 | 流）
    - 对于串来说只有一种实现方式，就是顺序表。因为串元素就是字节，字节用链式比较浪费。字符串 or 流的长度一般是固定的。
    - 如果对串修改，是要复制的。比如 java 中字符串的拼接是经过大量优化的额，建议使用 StringBuilder 而不是 String, 原因也在这。

* 树: 树是由若干个有限节点组成的一个具有层次关系的集合
  - 没有子节点的节点称为叶子节点 （就像一颗真正的树，树的叶子是不会再有后面的延伸了）
  - 每个节点有且仅有一个父节点，如果一个结构中的某个节点存在多个父节点那它就不是树
  - 树也一定时有个起始位置
    - 如果整个树只有一个节点就是单节点的树
    - 如果没有节点，也可以看成是一个空树
    - 但是如果存在循环的情况那就不是一个树，因为树一定有个起始位置

![img](/static/tree.png)

一棵二叉树由根结点、左子树和右子树三部分组成，若规定 D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的遍历方式有 6 种：DLR、DRL、LDR、LRD、RDL、RLD。由于先遍历左子树和先遍历右子树在算法设计上没有本质区别，所以，只讨论四种方式
在了解树的遍历之前先清楚下面这个概念：

> 根是相对的，对于整棵树而言只有一个根，但对于每棵子树而言，又有自己的根。比如对于下面三个图，对于整棵树而言，A 是根，A 分别在最前面、中间、后面被遍历到。而对于 D，它是 G 和 H 的根，对于 D、G、H 这棵小树而言，顺序分别是 DGH、GDH、GHD；对于 C，它是 E 和 F 的根，三种排序的顺序分别为： CEF、ECF、EFC。

- 树的遍历，按照某种规则，`不重复`的访问这个树的所有节点（遍历是一种有规律的递归过程）
  - 深度优先 （先，中，后是以根节点来说的）
    - 先序遍历: 先根再左最后右 【根在开始，所以是先序遍历】
    - 中序遍历： 先左再根最后右 【根在中间，所以是中序排列】 注意中序的第 5 步，如果 E 的左子树存在（比如为 E1）,那么 5 应该先访问 E1 再访问 E
    - 后序遍历：先左再右最后根 【根在最后，所以是后序遍历】
  - 广度优先
    - 层序遍历

![img](/static/tree-iterator.png)

- 树的衍生
  - 无序树: 树中任意节点的子结点之间没有顺序关系（比如 A，B 为兄弟节点，如果没有顺序关系，那么左子树为 A 或 B （AB, BA）都是一样的）
  - 有序树: 树中任意节点的子结点之间有顺序关系（比如 A，B 为兄弟节点，如果有顺序关系，那么 AB， BA 是两个不同的组合）
  - 二叉树: 每个节点最多含有两个子树的树称为二叉树
    - 完全二叉树: 除了最后一层，其它各层节点数都达到最大
    - 满二叉树: 每一层上的结点数都是最大结点数
    - 霍夫曼树: 带权路径最短的二叉树，也叫最优二叉树（树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL）
      霍夫曼树如下图所示：
      ![img](/static/Huffman-Tree.png)

* 图: 由顶点的集合（不能是空集）和边的集合组成的结构，表现的是多对多的关系
  - 几个基本的概念： 顶点，边，权（每条边的权重），有向图和无向图

---

# 算法

## 什么是算法：

算法是完成某个特定任务的过程，通常数据结构作为工具来辅助执行算法。
一个流传非常广的公式：`程序 = 数据结构 + 算法`

- 算法不是数学，但是可以用数学来描述
- 我们要做一件事情，这个做事情的过程就是一个算法
- 我们常用的增删改查也是算法的一部分
- 算法可以用自然语言，流程图，伪代码和计算机语言等手段来表示
- 在面向对象的语言中，算法通常通过类的方式来实现

算法就在我们身边，平时生活中做过什么？

- 排序算法
- 查找算法
- 推荐算法
- 贪心算法

## 算法的特征

- 有穷性：算法必须能在执行有限个步骤后终止
- 确切性：每一步骤必须有确切的定义
- 输入项：用 0 或者多个输入来规定初始的情况，所谓 0 个输入是指算法本身定出的初始条件
- 输出项：有一个或多个输出，是对数据输入处理后的结果，没有输出的算法毫无意义
- 可行性：算法中任意的计算步骤都是可以被分解为基本的可执行的操作步骤，每个计算步骤都可以在有限时间内完成（称为有效性）

## 怎样衡量一个算法的好坏

- 算法的好坏通过算法的复杂度来衡量（一般时间复杂度重于空间复杂度，两者同时兼具更好，否则用空间换时间）
  - 时间复杂度
  - 空间复杂度
- 正确性
- 可读性
- 健壮性

## 常见的时间复杂度

> 图中左侧图例的复杂度由低到高

![img](/static/time-complexity.png)

## 如何计算一个算法的复杂度？

- 随着问题规模 n 的不断扩大，时间复杂度不断扩大，算法的执行效率越低
- 一般做算法的复杂度分析的时候，遵循下面的准则
  - 有几重循环，一般来说一重就是 O(n), 两重就是 O(n^2), 以此类推 （但不是绝对的，有时也要根据循环的具体逻辑具体分析，后面例子中能看到）
  - 如果有二分，则为 O(logN)
  - 计算的结果中保留最高项，去除复杂度低 | 常数项

举例子：

```js
let i = 0; // 语句执行一次
while (i < n) {
  // 语句执行n次
  console.log("current value:", i); // 语句执行n次
  i++; // 语句执行n次
}

// 上面的算法复杂度：1 + n + n + n = 1 + 3n
// 去除常数项
// ===> 最终复杂度：O(n)
```

```js
let number = 1; // 语句执行1次
while (number < n) {
  // 一般循环时n次，但是此处注意具体逻辑，循环内有对判断的值做修改，*2相当于是二分查找，所以此处是 log(N)
  number *= 2; // 此次相当于二分查找 ==》 log(N)
}

// 上面算法复杂度：1 + log(N) + log(N) = 1 + 2log(N)
// 去除常数项
// log(N)
```

```js
for (let i = 0; i < n; i++) {
  // 执行n次
  for (let j = 0; j < n; j++) {
    // 执行 n^2次
    console.log("hello world"); // 执行 n^2次
  }
}

// 上面算法复杂度：n + n^2 + n^2 = n + 2n^2
// 去除常数项和低复杂度值
// O(n^2)
```

## 必须要掌握的算法

- 枚举
  - 核心思想：枚举所有可能
  - 本质：就是从所有的候选答案中去搜索正确的解，使用该算法需要满足两个条件
    - 可以预先确定候选答案的事项
    - 候选答案的范围在求解之前必须有一个确定的集合
  - 特点：枚举算法简单粗暴，暴力的枚举所有可能，尽可能的尝试所有的方法。
- 递归
  - 核心思想：通过重复将问题分解为同类的子问题从而解决问题的方法
  - 特点：
    - 函数可以调用自身来进行递归
    - 递归可以完全取代循环
  - 递归由下面两部分组成：
    - 递归主体：就是要循环解决问题的代码
    - 递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出
- 基本排序
  - 关注平均时间复杂度
  - 效率较低的是：冒泡，插入，选择。 比较基础，我们从算法的角度要掌握它，但是开发时避免使用它们
  - 还要关注稳定性 (比如A，B两个人年龄都是20岁，我们按年龄排序，多次排序有时A在前面，有时B在前面那么就是稳定性存在问题)
    ![img](/static/algorithm-order.png)

- 基本查找
  -  哈希表法比较常用，典型的用空间换时间
  ![img](/static/algorithm-find.png)


## 怎样养成算法思维：
自问自答：
- 结果是什么
- 步骤是什么
- 判断结果的标准是什么

- 化繁为简
  - 对于很难第一时间得到的正确思路，可以新不要考虑其他的诸如简洁性，性能如何如何，先能解决问题。下一步再去想如何去简化，优化它。
  - 复杂的问题可以把问题规模缩小到非常容易解答的地步，用来解决动态规划问题

- 分而治之
  - 把问题分为两半，变成与原来问题同构的问题
  - 需要考虑的两个问题
    - 一分为二后，问题是否被简化了
    - 根据分开后的问题的解，能否方便的得出整个问题的解

- 化虚为实
  - 使用另一种形式进行替换



### leetcode 算法题实际体验 和 查缺补漏








