# 前端中的数据结构和算法

> 程序 = 数据结构 + 算法

- 一个类就是在设计一个数据结构，一个接口就是在写一个自己设计的算法或者应用经典的算法
- 遇到一个【大的有序列表】来查找某一个记录的时候，可以使用二分查找的方法提高查询效率
- 程序中出现很多 for 的时候就要考虑使用算法了
- 程序数据杂乱无章的时候就有必要设置数据结构了

![img](/static/priority.png)

```js
// 看一段代码
var a = { n: 2 };
a.x = a = { n: 3 };
console.log(a.x); // undefined

// 为什么是undefined
// 第二部中js中【.】的优先级比较高，优先执行。具有相同优先级的运算符按从左至右的顺序求值
// a先在{n:2}中开辟新的属性x，存的是{n:2}当前的堆中地址，接着 a又全新被赋值为了{n:3}的堆中地址，此处是没有x属性的
// 所有 a.x 是undefined
```

```js
var s = [];
var arr = s;
for (var i = 0; i < 3; i++) {
  var pusher = {
      value: "item" + i
    },
    tmp;
  if (i !== 2) {
    tmp = [];
    pusher.children = tmp;
  }
  arr.push(pusher);
  arr = tmp;
}
console.log(s[0]);

// 输出结果
// {
//     value: item0,
//     children: [
//         {
//             value: item1,
//             children: [
//                 { value: item2 }
//             ]
//         }
//     ]
// }
```

## 关于递归的思考
递归解决的问题：递归是用于解决符合下面三个条件的问题的
- 一个问题可以分解为若干的子问题
- 子问题的逻辑和大问题除了数值不一样外，整体上保持一致
- 有终止或者退出的判断条件

递归使用需要注意的问题
- 几乎所有的递归都可以转换为循环去解决问题，但是这个转换对于我这个目前还不熟悉的人来说还是比较困难 （抽象出递推公式、初始值和边界条件，然后用迭代循环实现。）
- 每次递归到新的子问题时，父问题的的临时变量会封装为栈帧压入内存栈中，等函数执行结束才初栈，所以如果一个递归过深，临时变量过多会导致堆栈溢出

尾递归
- 在递归函数的返回最后一步是调用自身（直接调用，不参与任何逻辑），这样就变成一个循环体，只会保存当前一个函数的临时变量，不会出现溢出的问题
- 前提是编程语言支持了对尾递归的优化，如果编程语言底层不支持，尾递归也是没有用的。ECMAScript 6 已经支持

递归的实际应用场景
- kao的洋葱模型，use中async函数的递归调用
- dom diff算法 （diff就是差异的意思） 
  - dom元素中存在许多的属性和嵌套关系，操作dom是一件很消耗资源的事情，但是操作自定义的js确是比较高效
  - 我们在操作真实dom之前多加一层“虚拟的dom”，建立虚拟dom与真实dom的关联关系，先操作虚拟dom，再根据操作后的差异去修改真实的dom
  - 总结来说：给予一个数据，给予一个数据，根据这个数据生成一个全新的Virtual DOM，然后跟上一次生成的Virtual DOM去 diff，得到一一个Patch（变化地方的数组集合），然后把这个Patch打到浏览器的DOM上去，即可完成页面的更新改变
  - 为啥多加一层还变快了呢？DOM是很慢的，因为其元素非常庞大，所以采用js去表示DOM结构，而且只保留了Element之间的层次关系和一些基本属性，所以JS所表示的DOM树结构更加高效
  - 转化为数据结构和算法思维就是：树的深度遍历差异化，差异化信息保存在patch中。根据patch中的数据修改真实dom

## 去重和查询
在前端代码中可以考虑使用Set或者Map解决问题



