> 言尽于此，愿君之勿忘也 ······ 临颖神驰，书不成字，纸短情长，伏惟珍重 - 徐枕亚《玉梨魂》

这个真的是一个很大的话题额....

## 概述

前面有介绍过从网络和浏览器的角度，输入一个 URL 发生了上面。现在就将从新的角度输入 URL 发生了什么，以此引导出一个页面加载的不同阶段，每个阶段能够优化的地方。

![images](./images/performance.png)

图片中一共有 9 大步，每一步都对应一段操作：

> 1-3 缓存和准备工作 4-7 网络操作 8-9 数据获取后的处理

1. Prompt for unload [navigationStart 导航开始]
   - 发送老页面准备卸载的提醒
2. redirect & unload [`缓存优化`]
   - 本地重定向，先要从缓存中找。
   - 正式卸载老页面
3. App Cache
   - 操作浏览器缓存
4. 将站点的域名通过 DNS 转化为 IP [`CDN 优化`]
   - 浏览器获取 DNS 地址（从本机上获取，本机上的 DNS 是在连接路由器时由路由器将其和动态 IP 一起给予本机的）
5. 走 TCP 传输层协议 [`长连接，HTTP2、3 协议`]
   - 浏览器通过 DNS 将域名转化为 IP 地址，通过 IP 使用 TCP 协议连接服务器，可能中间包括安全连接
   - 每次开始连接 TCP 要进行三次握手
   - 结束后 TCP 断开连接四次挥手
6. Request 请求 [`服务器性能，吞吐量，代码优化`]
7. Response 响应 [`数据压缩优化 gzip`] （要寻找平衡点-因为压缩和解压缩也要消耗时间）
8. Processing 进程，解析（以返回 HTML 为例）[`代码质量和结构优化`]
   - 载入 DOM 到内存
   - 解析文档，生成 DOM
   - DOM 交互事件绑定
   - 渲染 DOM...【只渲染可视的部分】
9. OnLoad [`代码质量和结构优化`]

## 缓存优化

### 缓存的作用：

- 减少了冗余的数据传输。节省带宽
- 减少了服务器负担，提高 webapp 性能
- 加快客户端加载网页的速度

### 缓存的分类

- 缓存分为强制缓存和对比缓存，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互
- 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则

#### 强制缓存(首页没法强制缓存)

![img](./images/cache2.png)

- 响应头：`Expires`  

    设置到期时间`resp.setHeader('Expires', new Date(Date.now() + 10000).toUTCString());`

- 响应头：`Cache-Control`

    与 Expires 的作用一致，都是指明当前资源的有效期, 其优先级高于 Expires。 
    
    设置到期时间 `resp.setHeader('Cache-Control', 'max-age=10');`


#### 对比缓存
![img](./images/cache4.png)

- 响应头：`Last-Modified` 响应时告诉客户端此资源的最后修改时间

    请求头: `If-Modified-Since` 

    当资源过期时（使用Cache-Control标识的max-age到期），发现资源具有Last-Modified声明，则再次向服务器请求时带上头If-Modified-Since。

    服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应最新的资源内容并返回200状态码；

    若最后修改时间和If-Modified-Since一样，说明资源没有修改，则响应304表示未更新，告知浏览器继续使用所保存的缓存文件。

- 响应头：`ETag`，是实体标签的缩写，根据实体内容生成的一段hash字符串,可以标识资源的状态。当资源发生改变时，ETag也随之发生变化。 ETag是Web服务端产生的，然后发给浏览器客户端。

    请求头：`If-None-Match`

    客户端想判断缓存是否可用可以先获取缓存中文档的ETag，然后通过If-None-Match发送请求给Web服务器询问此缓存是否可用。

    服务器收到请求，将服务器的中此文件的ETag,跟请求头中的If-None-Match相比较,如果不一样则Web服务器将发送该文档的最新版本给浏览器客户端。

    如果值是一样的,说明缓存还是最新的,Web服务器将发送304 Not Modified响应码给客户端表示缓存未修改过，可以使用


相比较Last-Modified，ETag更准确，但是也最消耗性能。因为每次请求过来都要计算文件的hash与请求头中的If-None-Match的值来比较。

注意下面区别：
- 200 from memory cache
    - 不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当kill进程后，也就是浏览器关闭以后，数据将不存在。但是这种方式只能缓存派生资源
- 200 from disk cache
    - 不访问服务器，直接读缓存，从磁盘中读取缓存，当kill进程时，数据还是存在。这种方式也只能缓存派生资源
- 304 Not Modified
    - 访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据


下面总结下整个缓存的完整流程：
![img](./images/NetCacheFlow.jpg)

> 相关代码在：code/01-cache 文件夹中

## CDN 优化

## 连接协议优化

## 请求、响应优化

## 打包构建层面的优化

## 代码层面优化

## 如何分析并定位性能问题？
